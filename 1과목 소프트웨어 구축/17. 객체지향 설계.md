## 1. 객체지향(OOP, Object Oriented Programming)
### 1. 개념
- 현실 세계의 유형, 무형의 모든 대상을 객체(Object)로 나누고, 객체의 행동(Method)과 고유한 값(Attribute)을 정의하여 설계하는 방법
- 객체를 만들고 조작하며 객체끼리 관계를 맺음으로써 다수의 객체가 함께 수행될 수 있게 한다.
### 2. 구성요소
- 클래스(Class)
  - 유사한 종류의 유형/무형의 존재를 속성과 연산을 정의해서 만든 클
  - 다른 클래스와 독립적으로 디자인한다.
  - 데이터를 추상화하는 단위
- 객체(Object)
  - 클래스의 인스턴스
  - 객체는 자신 고유의 속성을 가지며, 클래스에서 정의한 연산을 수행
  - 객체의 연산은 클래스에 정의된 연산에 대한 정의를 공유함으로써 메모리를 경제적으로 사용
- 속성(Attribute)
  - 객체들이 가지고 있는 고유한 데이터를 단위별로 정의한것
  - 성질, 분류, 수량, 현재 상태 등에 대해서 표현한 값
- 메서드(Method)
  - 어떤 특정한 작업을 수행하기 위한 명령문의 집합
  - 객체가 가지고 있는 속성들을 변경할 수 있는 하나의 연산
- 메세지(Method)
  - 객체에게 어떤 행위를 하도록 지시
  - 객체의 메서드를 호출함으로써 객체간의 상호작용을 할 수 있도록 한다.
### 3. 특징
- 캡슐화(Encapsulation)
  - 속성(Attribute)과 속성을 조작하는 메서드(Method)를 하나로 묶은 것
  - 캡슐화된 객체의 세부내용은 외부에 은폐(정보은닉)되어, 오류의 파급효과가 적다.
  - 캡슐화된 객체들은 재사용이 용이
  - 캨체들 간의 메세지를 주고받을 때, 해당 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고, 결합도가 낮아진다.
- 정보은닉(Information Hiding)
  - 캡슐화의 가장 중요한 개념
  - 다른 객체들이 객체의 내부 데이터에 직접 접근할 수 없도록 제한하며, 오직 공개된 메서드를 통해서만 내부 상태에 접근할 수 있게 한다.
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 메서드를 하위 클래스가 물려받는것
  - 상속을 이용하면 하위 클래스는 상위 클래스의 속성과 메서드를 자신의 클래스에 다시 정의하지 않아도 된다.
- 다형성(Polymorphism)
  - 하나의 메세지에 대해 각 객체가 가지고 있는 여러 가지 방법으로 응답할 수 있는 개념
  - 객체에서 동일한 메서드명을 인자값의 유형이나 개수만 틀리게 하는 오버로딩이 존재
  - 객체에서 상속받은 메서드를 재정의하는 오버라이딩이 존재
- 추상화(Abstraction)
  - 실체의 핵심적인 개념만을 추출하여 간결한 형태로 표현하는 것
  - 하위 클래스에 존재하는 공통적인 메서드를 상위 클래스 혹은 인터페이스로 정의하고, 하위 클래스가 해당 메서드를 재정의 할 수 있도록 하는 것

### 4. 객체지향 설계원칙(SOLID)
- 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 한 클래스는 하나의 책임만을 가져야 한다.
- 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  - 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만, 수정에 대해서는 닫혀있어야 한다.
  - 기존의 코드를 변경하지 않으면서(Closed), 기능을 추가할 수 있도록(Open)설계
- 리스코프 치환 원칙(LSP, LisKov Subtitution Principle)
  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
  - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계회대로 작동해야 한다.
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
  - 자신이 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다.
- 의존성 역전 원칙(DIP, Dependency Inversion Priciple)
  - 의존 관계를 맺을 때 자주 변화하는 것보다 변화가 거의 없는 것에 의존해야 한다.
  - 구체적은 클래스보다 인터페이스나 추상 클래스와 의존 관계를 맺어야 한다.

## 2. 디자인패턴
### 1. 디자인패턴 개념
- 객체지향 프로그래밍 설계를 할 때 자주 발생하는 문제들에 대해 재사용할 수 있도록 만들어놓은 패턴들의 모음
### 2. 구조
- 패턴의 이름과 유형
- 문제 및 배경
- 솔루션
- 사례
- 결과
- 샘플 코드

### 3. GoF 디자인 패턴
- 23가지 디자인 패턴을 정리
- 각각을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류
#### Gof 디자인 패턴 분류
- 생성 패턴
  - 객체 생성과 관련한 패턴
- 구조 패턴
  - 클래스나 객체를 조합해서 더 큰 구조를 만드는 패턴
- 행위 패턴
  - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
### 4. 디자인 패턴 종류
#### 1. 생성 패턴
- 객체 생성에 관련된 패턴
#### 종류
- 추상팩토리
  - 구체적인 클래스에 의존하지 않는다.
- 빌더
  - 복합 객체의 생성과 표현을 분리했다.
- 팩토리 메서드
  - 객체 생성을 서브클래스로 위임하여 캡슐화 함
- 프로토타입
  - 원본 객체를 복사함으로써 객체를 생성함
- 싱글톤
  - 인스턴스는 하나임을 보장
#### 2. 구조패턴
- 클래스나 객체를 조합해서 더 큰 구조를 만드는 패턴
- 상속을 통해 클래스나 인터페이스를 합성하는 방법을 정의
#### 종류
- 어댑터
  - 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함
- 브릿지
  - 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함
- 컴포지트
  - **객체들의 관계를 트리 구조로 구성하여** 복합 객체와 단일 객체를 구분 없이 다룸
- 데코레이터
  - 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식
- 퍼사드
  - 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스를 제공(Wrapper)
- 플라이웨이트
  - 크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약함
- 프록시
  - 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 대리나 대체글을 제공

#### 3. 행위 패턴
- 객체나 클래스들이 상호작용하는 방법 및 책임을 정의하는 패턴
- 객체 사이의 효율적인 커뮤니케이션 책임 할당을 돕는다.
#### 종류
- 책임 연쇄
  - 한 객체가 처리할 수 없는 요청을 다음 객체로 전달하는 방식
- 커맨드
  - **실행될 기능을 캡슐화함으로써** 주어진 조건을 만족하는 기능을 실행할 수 있는 유연성을 제공한다.
- 인터프리터
  - 주어진 언어에 대해, 그 언어의 문법에 대한 표현을 정의하고 해당 언어를 해석하는 해석자를 위한 패턴
- 반복자
  - 컬렉션 객체의 내부 구조를 노출시키지 않고도 그 원소들에 접근할 수 있는 방법을 제공
- 중재자
  - 객체 간의 복잡한 상호작용을 캡슐화하고, 객체들이 서로 직접 참조하지 않도록 중재자 객체를 통해 통신하도록 만든다.
- 메멘토
  - 객체의 상태 정보를 저장하고 필요에 따라 이전 상태로 복원할 수 있는 기능을 제공
- 옵서버
  - 상태 변화가 있을때마다 메서드를 통해 객체가 직접 목록의 관찰자에게 통지하도록 한다.
- 상태
  - 객체의 내부 상태에 따라 동일한 작업이 상태에 따라 다르게 작동하도록 **상태를 객체로 표현한다.**
- 전략
  - **알고리즘**을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 만든다.
- 템플릿 메소드
  - 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 한다.
- 방문자
  - 객체 구조를 이루는 원소에 대한 연산을 정의하는 데 사용되는 패턴