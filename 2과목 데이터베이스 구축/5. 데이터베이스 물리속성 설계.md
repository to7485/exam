## 1. 파티셔닝
### 1. 개념
- 데이터베이스의 특정 부분(데이터)을 여러 섹션으로 분할하는 방법
- 대용량 데이터의 조회 속도 향상, 관리 용이성, 성능 및 가용성 향상을 위해 사용
### 2. 샤딩(Sharding)
- 거대한 데이터베이스나 시스템을 작은 조각(샤드)으로 나누어 분산 저장 및 관리하는 기법
- 데이터의 크키가 매우 클 때 효과적
- 샤드(Shard)는 나눠진 데이터 블록의 구간(Epoch)을 의미
### 3. 장/단점
- 장점
  - 데이터 가용성 향상
  - 파티션별 독립적인 백업 및 복구 가능
  - 성능 향상
- 단점
  - 테이블 간의 조인 비용 증가
  - 테이블과 인덱스는 동일한 파티션 전략을 따라야 함

### 4. 파티셔닝 종류
#### 1. 수평분할(Horizontal Partitioning)
- 테이블의 행을 기준으로 분할
- 스키마를 복제한 후 샤드키를 기준으로 데이터를 나눈다.
#### 2. 수직분할(Vertical Partitioning)
- 테이블의 컬럼을 기준으로 분할아여 성능 향상
- 자주 사용하는 컬럼 등을 분리시켜 성능을 향상
- 하나의 테이블을 2개 이상으로 분리하는 작업

### 5. 분할 기준
#### 1. 범위 분할
- Partition Key의 연속된 범위로 파티션을 정의
- ex) 월별, 분기별 등

```sql
CREATE TABLE TB_USER{
    id INT,
    year INT
}

PARTITION BY (RANGE)빈칸으로 나올 수 있음 (year)(
    PARTITION U1 VALUES LESS THAN (2000),
    PARTITION U1 VALUES LESS THAN (2010),
    PARTITION U1 VALUES LESS THAN (2020)
);
```

#### 2. 목록 분할
- 특정 Partition에 저장될 Data에 대한 명시적 제어
- ex) [한국, 일본, 중국 -> 아시아], [노르웨이 스웨덴, 핀란드 -> 북유럽]

```sql
CREATE TABLE TB_STUDENT{
    id INT,
    grade INT
}

PARTITION BY (LIST)빈칸으로 나올 수 있음 (grade)(
    PARTITION high_grade VALUES IN (1,2,3),
    PARTITION high_grade VALUES IN (4,5,6)
);
```

#### 3. 해시 분할
- 파티션 키 값에 해시 함수를 적용하고, 거기서 반환된 값으로 파티션 매핑
- 데이터가 모든 파티션에 고르게 분산되도록 DBMS가 관리
- 병렬 처리 시 성능효과 극대화

#### 4. 라운드 로빈 분할
- 데이터를 균일하게 분배해서 저장하는 방식

#### 5. 합성 분할
- 위의 기술들을 복합적으로 사용하는 방법
- ex) 범위 분할 후 분할된 데이터를 해시 분할하는 경우 등

## 2. 클러스터 설계
### 1. 클러스터의 개념
- 자주 사용되는 테이블의 데이터를 디스크 상 동일한 위치에 저장하여 데이터 액세스 효율을 향상시키는 물리적 저장 방법

### 2. 특징
- 그룹화된 데이터는 같은 데이터 블록에 저장되어 디스크 I/O를 최소화
- 클러스터링 테이블 간의 조인 성능 향상
- 데이터 조회 성능은 향상되지만, 데이터의 추가/수정/삭제나 전체 스캔 시 성능 저하 가능
- 데이터의 분포고다 넓을 경우 더 유리함
- 클러스터링된 테이블에서는 클러스터드 인덱스 생성 시 성능 향상

### 3. 클러스터 대상 테이블
- 데이터 분포도가 넓은 테이블
- 대량 데이터 범위 조회가 빈번한 테이블
- 자주 변경(추가/수정/삭제)되지 않는 테이블
- 자주 조인되는 테이블
- 정렬, 그룹화, 연합 연산이 자주 사용되는 테이블

## 3. 인덱스(Index)
### 1. 인덱스의 개념
- 데이터베이스 테이블 검색 속도 향상을 위한 저장 공간 활용 자료구조
- 책의 색인과 유사하며, 빠른 조회를 위해 데이터 위치 정보를 포함
### 2. 인덱스를 사용하는 이유
- 대규모 테이블에서의 빠른 데이터 추출
- 조건 검색, 정렬, MIN/MAX 처리의 효율 향상
- JOIN시 열 추출 효율성 

### 3. 인덱스의 종류
#### 1. 클러스터 인덱스
- 테이블당 1개만 허용되며, 해당 컬럼을 기준으로 테이블이 물리적으로 정렬
- 데이터는 기본적으로 오름차순으로 정렬을 진행
- 기본키를 설정하면 자동으로 클러스터드 인덱스가 적용
- 인덱스 자체의 리프 페이지가 곧 데이터
- 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지
- 비 클러스터형 인덱스보다 검색 속도는 빠르나, 데이터의 입력, 수정, 삭제시에는 느림

#### 2. 넌클러스터 인덱스
- 테이블당 약 240개의 인덱스 생성 가능
- 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬
- 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 포인터(RID)이기 때문에 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력, 수정,삭제는 더 빠름
- 인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지함

#### 3. 밀집 인덱스
- 데이터 레코드 각각에 대해 하나의 인덱스가 만들어진

#### 4. 희소 인덱스
- 레코드 그룹 도는 데이터 블록에 대해 하나의 인덱스가 만들어짐

### 4. 인덱스의 구조
#### 1. 트리 기반 인덱스
- 대부분의 상용 DBMS는 데이터 검색 효율을 높이기 위해 B+ 트리 인덱스를 사용한다.
- B+ 트리는 밸런스가 잘 맞춰진 트리 구조로, 루트에서 리프노드까지 모든 경로의 깊이가 동일하다.
- 대용량 데이터에서 삽입, 삭제, 검색 작업에 효율적이다.
- 특히 범위 검색에 효율적이다.

#### 2. 비트맵 인덱스
- 주로 값의 범위가 제한적인 컬럼에 사용되며, 각 값에 대한 비트 배열을 사용하여 인덱싱한다.
- 데이터베이스에서 키 값이 있는 로우의 위치를 빠르게 식별할 수 있게 해준다.
- 주로 읽기 중심의 데이터베이스에서 유리하며, 쓰기 작업(삽입, 수정, 삭제)이 많은 환경에서는 성능 저하가 발생할 수 있다.

#### 3. 함수 기반 인덱스
- 컬럼 값이 아닌 특정 함수의 결과에 대해 인덱스를 생성한다.
- 복잡한 쿼리 조건을 인덱싱 할 수 있어, 쿼리 성능 향상에 도움을 줄 수 있다.
- 다양한 함수(산술, SQL함수 패키지 등)를 사용하여 인덱스를 구성할 수 있다.

#### 4. 비트맵 조인 인덱스
- 비트맵 인덱스의 확장으로, 주로 조인 연산을 최적화하기 위해 사용된다.
- 한 테이블의 컬럼이 아닌, 조인된 다른 테이블의 컬럼 값을 인덱싱한다.
- 조인된 테이블의 데이터 변화에 따라 인덱스를 재구성해야 할수도 있다.

#### 5. 도메인 인덱스
- 도메인 인덱스는 사용자 정의 인덱스로, 특정 애플리케이션에 특화된 인덱싱을 구현할 수 있다.
- 개발자는 자신의 요구사항에 맞춰 특정한 인덱스 타입을 만들 수 있다.
- 복잡하거나 특수한 데이터 구조를 효율적으로 처리할 수 있도록 도와준다.


### 5. 인덳스 컬럼의 선정
- 분포도가 좋은(10% ~ 15%)컬럼
- 자주 조합되어 사용되는 경우 결합 인덱스를 생성
- 가능한 수정이 빈번하지 않은 컬럼을 선정
- 한 컬럼이 여러 인덱스 포함되지 않도록 설계
- 기본키 및 외부키가 되는 컬럼을 선정

### 6. 인덱스 생성시 고려사항
- 새로 추가된 인덱스 기존 액세스 경로에 영향을 미칠 수 있다.
- 지나치게 많은 인덱스는 오버헤드를 발생시킨다.
- 넓은 범위를 인덱스로 처리 시 많은 오버헤드를 발생시킨다.
- 옵티마이저를 위한 통계 데이터를 주기적으로 갱신한다.
- 인덱스를 위한 추가적인 저장공간이 필요.

### 7. 인덱스 생성/삭제
#### 1. 인덱스 생성
```SQL
--문법
CREATE INDEX [인덱스명] ON [테이블명] (컬럼1, 컬럼2, 컬럼3...);

--예제
CREATE INDEX USER_INDEX ON TB_USER(NAME,HP);
```
#### 2. 인덱스 삭제
```SQL
--문법
DROP INDEX 인덱스명;

--예제
DROP INDEX USER_INDEX;
```

#### 3. 인덱스 재구성
```SQL
--문법
ALTER INDEX 인덱스명 REBUILD;

--예제
ALTER INDEX USER_INDEX REBUILD;
```

## 4.뷰
### 1. 개념
- 기본테이블에서 유도된 이름이 있는 가상 테이블
- 실제 데이터는 저장하지 않고 논리적으로만 존재
- 사용자는 실제 테이블과 같이 뷰를 조작 가능
### 2. 뷰의 특징
- 기본 테이블 유도로, 기본 테이블과 유사한 형태와 조작을 갖는다.
- 물리적 구현 없는 가상 테이블
- 논리적 데이터 독립성 제공
- 관리 용이 및 명령문 간소화(필요한 데이터만 처리)
- 뷰를 통한 데이터 접근으로 안전 보호
- 데이터 조작(삽입,삭제,갱신)에 제한 존재
- 기본 테이블/뷰 삭제 시 관련 뷰도 자동 삭제
- 생성은 'CREATE', 삭제는 'DROP'으로 가능하며, 변경은 'ALTER'로 불가
### 3. 뷰의 장/단점
- 장점
  - 논리적 데이터 독립성
  - 다양한 사용자 요구에 대한 동시 지원
  - 간결한 데이터 관리
  - 자동 보안 제공(접근 제어)
- 단점
  - 독립적 인덱스 부재
  - ALTER VIEW 사용 불가
  - 뷰 조작(삽입,삭제,갱신 등)에 제약 존재

## 5. 시스템 카탈로그
### 1. 시스템 카탈로그
- 데이터베이스의 모든 데이터 개체들에 대한 정보를 저장한 시스템 테이블로, 데이터 사전(Data Dictionary)이라고도 한다.
- DDL의 결과로 생성되는 데이터베이스 구조와 관련 통계 정보가 저장된다.
- 이러한 정보를 메타데이터라고 부른다.
- 사용자와 DBMS모두가 접근 가능하다.

### 2. 시스템 카탈로그의 내용
- 릴레이션 관련 정보
  - 이름, 저장된 파일 정보, 속성 정보, 인덱스 이름, 무결성 제약 조건
- 인덱스 관련 정보
  - 이름, 구조, 인덱스 키 정보 등
- 뷰 관련 정보
  - 이름, 정의 소유자 등
- 통계 관련 정보
  - 릴레이션과 인덱스의 카디널리티, 인덱스의 높이와 범위 등
- 사용자 관련 정보
  - 계정과 권한 정보

### 3. 시스템 카탈로그의 특징
- 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있으며, 사용자는 SQL을 사용하여 내용을 조회할 수 있다.
- DBMS에 의해 생성되고 유지된다.
- 사용자는 시스템 카탈로그를 직접 갱싱할 수 없다.

